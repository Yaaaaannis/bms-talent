'use client'
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, createContext, useContext, useState, useEffect } from 'react'
import { useGLTF, shaderMaterial } from '@react-three/drei'
import { useFrame, extend } from '@react-three/fiber'
import * as THREE from 'three'

// Déclaration TypeScript pour le shader personnalisé
/* eslint-disable @typescript-eslint/no-namespace */
declare global {
  namespace JSX {
    interface IntrinsicElements {
      simpleColorMaterial: object
    }
  }
}
/* eslint-enable @typescript-eslint/no-namespace */

// Contexte pour partager les états de hover
interface HoverContextType {
  hoveredCard: { id: string; color: string; bounds: DOMRect | null } | null;
  setHoveredCard: (card: { id: string; color: string; bounds: DOMRect | null } | null) => void;
  mousePosition: { x: number; y: number };
}

const HoverContext = createContext<HoverContextType>({
  hoveredCard: null,
  setHoveredCard: () => {},
  mousePosition: { x: 0, y: 0 }
});

export const useHover = () => useContext(HoverContext);

export const HoverProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [hoveredCard, setHoveredCard] = useState<{ id: string; color: string; bounds: DOMRect | null } | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePosition({
        x: e.clientX / window.innerWidth,
        y: e.clientY / window.innerHeight
      });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return (
    <HoverContext.Provider value={{ hoveredCard, setHoveredCard, mousePosition }}>
      {children}
    </HoverContext.Provider>
  );
};

// Shader material simplifié pour changement de couleur qui suit la souris
const SimpleColorMaterial = shaderMaterial(
  {
    hoveredBounds: new THREE.Vector4(0, 0, 0, 0), // x, y, width, height en coordonnées NDC
    mousePosition: new THREE.Vector2(0, 0),
    isHovered: false,
    hoverColor: new THREE.Color('#ff0000'), // Rouge dur
    hoverRadius: 0.15, // Rayon autour de la souris
    // Propriétés du matériau de base
    color: new THREE.Color('#ffffff'),
    metalness: 0.1,
    roughness: 0.05,
    transmission: 0.8,
    opacity: 0.7,
    emissive: new THREE.Color('#ffffff'),
    emissiveIntensity: 0.3,
  },
  // Vertex shader
  `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    
    void main() {
      vPosition = position;
      vNormal = normal;
      vUv = uv;
      
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vec4 screenPosition = projectionMatrix * viewMatrix * worldPosition;
      vScreenPosition = screenPosition;
      
      gl_Position = screenPosition;
    }
  `,
  // Fragment shader avec effet qui suit la souris
  `
    uniform vec4 hoveredBounds;
    uniform vec2 mousePosition;
    uniform bool isHovered;
    uniform vec3 hoverColor;
    uniform float hoverRadius;
    
    uniform vec3 color;
    uniform float metalness;
    uniform float roughness;
    uniform float transmission;
    uniform float opacity;
    uniform vec3 emissive;
    uniform float emissiveIntensity;
    
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    
    void main() {
      // Calcul des coordonnées écran normalisées
      vec2 screenUV = (vScreenPosition.xy / vScreenPosition.w) * 0.5 + 0.5;
      screenUV.y = 1.0 - screenUV.y; // Inverser Y pour correspondre aux coordonnées DOM
      
      vec3 finalColor = color;
      vec3 finalEmissive = emissive;
      float finalEmissiveIntensity = emissiveIntensity;
      
      if (isHovered) {
        // Vérifier si le fragment est dans les bounds de la case survolée
        bool inBounds = screenUV.x >= hoveredBounds.x && 
                       screenUV.x <= hoveredBounds.x + hoveredBounds.z &&
                       screenUV.y >= hoveredBounds.y && 
                       screenUV.y <= hoveredBounds.y + hoveredBounds.w;
        
        if (inBounds) {
          // Calculer la distance de la position de la souris
          float distFromMouse = length(screenUV - mousePosition);
          
          // Appliquer l'effet rouge dans un rayon autour de la souris
          if (distFromMouse < hoverRadius) {
            // Créer un dégradé doux vers les bords
            float intensity = 1.0 - smoothstep(0.0, hoverRadius, distFromMouse);
            
            // Appliquer la couleur rouge dur avec l'intensité
            finalColor = mix(color, hoverColor, intensity);
            finalEmissive = mix(emissive, hoverColor, intensity);
            finalEmissiveIntensity = mix(emissiveIntensity, 1.0, intensity);
          }
        }
      }
      
      // Simuler un matériau physique simple
      vec3 normal = normalize(vNormal);
      float fresnel = pow(1.0 - dot(normal, vec3(0.0, 0.0, 1.0)), 2.0);
      
      vec3 result = finalColor + finalEmissive * finalEmissiveIntensity;
      result = mix(result, finalColor * 1.2, fresnel * 0.3);
      
      gl_FragColor = vec4(result, opacity + transmission * 0.1);
    }
  `
);

extend({ SimpleColorMaterial });

interface ModelProps {
  position?: [number, number, number];
  [key: string]: unknown;
}

interface GLTFResult {
  nodes: { [key: string]: THREE.Mesh };
  materials: { [key: string]: THREE.Material };
}

export function BmsModel(props: ModelProps) {
  const { nodes } = useGLTF('/bms.glb') as unknown as GLTFResult
  const meshRef = useRef<THREE.Mesh>(null!)
  const materialRef = useRef<THREE.ShaderMaterial>(null!)
  const { hoveredCard, mousePosition } = useHover();
  
  useFrame((state) => {
    const time = state.clock.getElapsedTime()
    if (meshRef.current) {        
      // Mouvement de flottement léger
      meshRef.current.position.y = Math.sin(time * 0.6) * 0.3
      meshRef.current.position.x = Math.cos(time * 0.3) * 0.2
    }
    
    if (materialRef.current && materialRef.current.uniforms) {
      // Toujours mettre à jour la position de la souris
      materialRef.current.uniforms.mousePosition.value = new THREE.Vector2(mousePosition.x, mousePosition.y);
      
      if (hoveredCard && hoveredCard.bounds) {
        materialRef.current.uniforms.isHovered.value = true;
        
        // Convertir les bounds DOM en coordonnées NDC
        const bounds = hoveredCard.bounds;
        const x = bounds.left / window.innerWidth;
        const y = bounds.top / window.innerHeight;
        const width = bounds.width / window.innerWidth;
        const height = bounds.height / window.innerHeight;
        
        materialRef.current.uniforms.hoveredBounds.value = new THREE.Vector4(x, y, width, height);
      } else {
        materialRef.current.uniforms.isHovered.value = false;
      }
    }
  })

  return (
    <group {...props} dispose={null}>
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        geometry={nodes.Fichier_2?.geometry}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.203}
      >
        <primitive
          ref={materialRef}
          object={new SimpleColorMaterial()}
          transparent={true}
          side={THREE.DoubleSide}
        />
      </mesh>
    </group>
  )
}

useGLTF.preload('/bms.glb')




