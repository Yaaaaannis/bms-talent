'use client'
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, createContext, useContext, useState, useEffect } from 'react'
import { useGLTF, shaderMaterial } from '@react-three/drei'
import { useFrame, extend } from '@react-three/fiber'
import * as THREE from 'three'

// Déclaration TypeScript pour le shader personnalisé
/* eslint-disable @typescript-eslint/no-namespace */
declare global {
  namespace JSX {
    interface IntrinsicElements {
      simpleColorMaterial: object
    }
  }
}
/* eslint-enable @typescript-eslint/no-namespace */

// Contexte pour partager les états de hover
interface HoverContextType {
  hoveredCard: { id: string; color: string; bounds: DOMRect | null } | null;
  setHoveredCard: (card: { id: string; color: string; bounds: DOMRect | null } | null) => void;
  mousePosition: { x: number; y: number };
}

const HoverContext = createContext<HoverContextType>({
  hoveredCard: null,
  setHoveredCard: () => {},
  mousePosition: { x: 0, y: 0 }
});

export const useHover = () => useContext(HoverContext);

export const HoverProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [hoveredCard, setHoveredCard] = useState<{ id: string; color: string; bounds: DOMRect | null } | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePosition({
        x: e.clientX / window.innerWidth,
        y: e.clientY / window.innerHeight
      });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return (
    <HoverContext.Provider value={{ hoveredCard, setHoveredCard, mousePosition }}>
      {children}
    </HoverContext.Provider>
  );
};

// Shader material simplifié pour changement de couleur qui suit la souris
const SimpleColorMaterial = shaderMaterial(
  {
    hoveredBounds: new THREE.Vector4(0, 0, 0, 0), // x, y, width, height en coordonnées NDC
    mousePosition: new THREE.Vector2(0, 0),
    isHovered: false,
    hoverColor: new THREE.Color('#ff0000'), // Couleur dynamique selon la case
    hoverRadius: 0.15, // Rayon autour de la souris
    emissionBoost: 1.0, // Multiplicateur d'émission selon la case
    // Propriétés du matériau de base - Aspect métallique sombre
    color: new THREE.Color('#2a2a2a'), // Gris foncé métallique
    metalness: 0.9, // Très métallique
    roughness: 0.2, // Légèrement rugueux pour l'effet brossé
    transmission: 0.0, // Pas de transmission pour un aspect solide
    opacity: 1.0, // Complètement opaque
    emissive: new THREE.Color('#1a1a1a'), // Émission très subtile
    emissiveIntensity: 0.1,
  },
  // Vertex shader
  `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    
    void main() {
      vPosition = position;
      vNormal = normal;
      vUv = uv;
      
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vWorldPosition = worldPosition.xyz;
      vWorldNormal = normalize(normalMatrix * normal);
      
      vec4 screenPosition = projectionMatrix * viewMatrix * worldPosition;
      vScreenPosition = screenPosition;
      
      gl_Position = screenPosition;
    }
  `,
  // Fragment shader pour effet wireframe/contour lumineux
  `
    uniform vec4 hoveredBounds;
    uniform vec2 mousePosition;
    uniform bool isHovered;
    uniform vec3 hoverColor;
    uniform float hoverRadius;
    uniform float emissionBoost;
    
    uniform vec3 color;
    uniform float metalness;
    uniform float roughness;
    uniform float transmission;
    uniform float opacity;
    uniform vec3 emissive;
    uniform float emissiveIntensity;
    
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    varying vec3 vWorldPosition;
    varying vec3 vWorldNormal;
    
    // Éclairage simple pour simuler les lumières de la scène
    vec3 calculateLighting(vec3 worldPos, vec3 worldNormal) {
      vec3 lighting = vec3(0.0);
      
      // Lumière ambiante
      lighting += vec3(0.1);
      
      // Lumière directionnelle principale (simule la directionalLight de la scène)
      vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));
      float diff = max(dot(worldNormal, lightDir), 0.0);
      lighting += vec3(1.5) * diff;
      
      // Point lights (simule les lumières de la scène)
      vec3 pointLight1Pos = vec3(3.0, 3.0, 2.0);
      vec3 pointLight1Dir = normalize(pointLight1Pos - worldPos);
      float pointLight1Dist = length(pointLight1Pos - worldPos);
      float pointLight1Att = 1.0 / (1.0 + 0.1 * pointLight1Dist + 0.01 * pointLight1Dist * pointLight1Dist);
      float pointLight1Diff = max(dot(worldNormal, pointLight1Dir), 0.0);
      lighting += vec3(1.0, 1.0, 1.0) * 2.0 * pointLight1Diff * pointLight1Att;
      
      vec3 pointLight2Pos = vec3(-3.0, -3.0, 2.0);
      vec3 pointLight2Dir = normalize(pointLight2Pos - worldPos);
      float pointLight2Dist = length(pointLight2Pos - worldPos);
      float pointLight2Att = 1.0 / (1.0 + 0.1 * pointLight2Dist + 0.01 * pointLight2Dist * pointLight2Dist);
      float pointLight2Diff = max(dot(worldNormal, pointLight2Dir), 0.0);
      lighting += vec3(1.0, 1.0, 1.0) * 2.0 * pointLight2Diff * pointLight2Att;
      
      return lighting;
    }
    
    void main() {
      // Calcul des coordonnées écran normalisées
      vec2 screenUV = (vScreenPosition.xy / vScreenPosition.w) * 0.5 + 0.5;
      screenUV.y = 1.0 - screenUV.y;
      
             vec3 normal = normalize(vNormal);
       vec3 worldNormal = normalize(vWorldNormal);
       vec3 viewDir = normalize(-vPosition);
       
       // Calculer l'éclairage de la scène
       vec3 lighting = calculateLighting(vWorldPosition, worldNormal);
       
       // Calcul de l'effet de contour plus net et droit
       float fresnel = 1.0 - abs(dot(normal, viewDir));
       float edgeIntensity = pow(fresnel, 4.0); // Plus de puissance pour des bords plus nets
       
       // Couleur de base pour l'effet wireframe
       vec3 wireframeColor = vec3(0.8, 0.9, 1.0); // Blanc légèrement bleuté
       float baseIntensity = 0.4;
      
      // Effet de hover avec couleurs spécifiques
      vec3 finalWireframeColor = wireframeColor;
      float finalIntensity = baseIntensity;
      
      if (isHovered) {
        bool inBounds = screenUV.x >= hoveredBounds.x && 
                       screenUV.x <= hoveredBounds.x + hoveredBounds.z &&
                       screenUV.y >= hoveredBounds.y && 
                       screenUV.y <= hoveredBounds.y + hoveredBounds.w;
        
        if (inBounds) {
          float distFromMouse = length(screenUV - mousePosition);
          
          if (distFromMouse < hoverRadius) {
            float intensity = 1.0 - smoothstep(0.0, hoverRadius, distFromMouse);
            
            // Mélanger avec la couleur de la carte
            finalWireframeColor = mix(wireframeColor, hoverColor.rgb, intensity * 0.7);
            finalIntensity = mix(baseIntensity, emissionBoost, intensity * 0.8);
          }
        }
      }
      
             // Créer l'effet wireframe unifié
       vec3 result = vec3(0.0); // Fond noir
       
       // Un seul rendu de contour pour éviter le dédoublement
       if (edgeIntensity > 0.05) {
         float edgeOpacity = smoothstep(0.05, 0.6, edgeIntensity);
         // Appliquer l'éclairage aux contours
         result = finalWireframeColor * finalIntensity * edgeOpacity * lighting;
       }
       
       // Transparence basée uniquement sur la présence des contours
       float alpha = edgeIntensity > 0.05 ? 1.0 : 0.0;
       
       gl_FragColor = vec4(result, alpha);
    }
  `
);

extend({ SimpleColorMaterial });

interface ModelProps {
  position?: [number, number, number];
  [key: string]: unknown;
}

interface GLTFResult {
  nodes: { [key: string]: THREE.Mesh };
  materials: { [key: string]: THREE.Material };
}

export function BmsModel(props: ModelProps) {
  const { nodes } = useGLTF('/bms.glb') as unknown as GLTFResult
  const meshRef = useRef<THREE.Mesh>(null!)
  const materialRef = useRef<THREE.ShaderMaterial>(null!)
  const { hoveredCard, mousePosition } = useHover();
  
  // Fonction pour obtenir les propriétés spécifiques à chaque case
  const getCardProperties = (cardId: string, color: string) => {
    switch (cardId) {
      case 'main': // Rouge - EXPLORE 500+ MASTERCLASSES
        return {
          hoverColor: new THREE.Color(color).multiplyScalar(1.2), // Rouge intense
          emissionBoost: 2.0,
          hoverRadius: 0.18
        };
      case 'filming': // Vert - FILMING
        return {
          hoverColor: new THREE.Color(color).multiplyScalar(1.5), // Vert brillant
          emissionBoost: 1.8,
          hoverRadius: 0.15
        };
      case 'music': // Bleu - MUSIC  
        return {
          hoverColor: new THREE.Color(color).multiplyScalar(1.3), // Bleu électrique
          emissionBoost: 2.2,
          hoverRadius: 0.16
        };
      case 'art': // Jaune - ART
        return {
          hoverColor: new THREE.Color(color).multiplyScalar(1.4), // Jaune doré
          emissionBoost: 2.5,
          hoverRadius: 0.17
        };
      case 'writing': // Orange - WRITING
        return {
          hoverColor: new THREE.Color(color).multiplyScalar(1.3), // Orange vibrant
          emissionBoost: 1.9,
          hoverRadius: 0.14
        };
      default:
        return {
          hoverColor: new THREE.Color('#ff0000'),
          emissionBoost: 1.0,
          hoverRadius: 0.15
        };
    }
  };
  
  useFrame((state) => {
    const time = state.clock.getElapsedTime()
    if (meshRef.current) {        
      // Mouvement de flottement léger
      meshRef.current.position.y = Math.sin(time * 0.6) * 0.3
      meshRef.current.position.x = Math.cos(time * 0.3) * 0.2
    }
    
    if (materialRef.current && materialRef.current.uniforms) {
      // Toujours mettre à jour la position de la souris
      materialRef.current.uniforms.mousePosition.value = new THREE.Vector2(mousePosition.x, mousePosition.y);
      
      if (hoveredCard && hoveredCard.bounds) {
        materialRef.current.uniforms.isHovered.value = true;
        
        // Obtenir les propriétés spécifiques à la case
        const cardProps = getCardProperties(hoveredCard.id, hoveredCard.color);
        
        materialRef.current.uniforms.hoverColor.value = cardProps.hoverColor;
        materialRef.current.uniforms.emissionBoost.value = cardProps.emissionBoost;
        materialRef.current.uniforms.hoverRadius.value = cardProps.hoverRadius;
        
        // Convertir les bounds DOM en coordonnées NDC
        const bounds = hoveredCard.bounds;
        const x = bounds.left / window.innerWidth;
        const y = bounds.top / window.innerHeight;
        const width = bounds.width / window.innerWidth;
        const height = bounds.height / window.innerHeight;
        
        materialRef.current.uniforms.hoveredBounds.value = new THREE.Vector4(x, y, width, height);
      } else {
        materialRef.current.uniforms.isHovered.value = false;
      }
    }
  })

  return (
    <group {...props} dispose={null}>
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        geometry={nodes.Fichier_2?.geometry}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.203}
      >
        <primitive
          ref={materialRef}
          object={new SimpleColorMaterial()}
          transparent={true}
          side={THREE.FrontSide}
      />
      </mesh>
    </group>
  )
}

useGLTF.preload('/bms.glb')




