'use client'
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, createContext, useContext, useState, useEffect } from 'react'
import { useGLTF, shaderMaterial } from '@react-three/drei'
import { useFrame, extend } from '@react-three/fiber'
import * as THREE from 'three'

// Déclaration TypeScript pour le shader personnalisé
declare global {
  namespace JSX {
    interface IntrinsicElements {
      waveShaderMaterial: THREE.ShaderMaterial;
    }
  }
}

// Contexte pour partager les états de hover
interface HoverContextType {
  hoveredCard: { id: string; color: string; bounds: DOMRect | null } | null;
  setHoveredCard: (card: { id: string; color: string; bounds: DOMRect | null } | null) => void;
  mousePosition: { x: number; y: number };
}

const HoverContext = createContext<HoverContextType>({
  hoveredCard: null,
  setHoveredCard: () => {},
  mousePosition: { x: 0, y: 0 }
});

export const useHover = () => useContext(HoverContext);

// Fonction pour calculer la couleur complémentaire
const getComplementaryColor = (hexColor: string): string => {
  // Convertir hex en RGB
  const hex = hexColor.replace('#', '');
  const r = parseInt(hex.substr(0, 2), 16);
  const g = parseInt(hex.substr(2, 2), 16);
  const b = parseInt(hex.substr(4, 2), 16);
  
  // Calculer la couleur complémentaire
  const compR = 255 - r;
  const compG = 255 - g;
  const compB = 255 - b;
  
  // Convertir back en hex
  return `#${compR.toString(16).padStart(2, '0')}${compG.toString(16).padStart(2, '0')}${compB.toString(16).padStart(2, '0')}`;
};

export const HoverProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [hoveredCard, setHoveredCard] = useState<{ id: string; color: string; bounds: DOMRect | null } | null>(null);
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      setMousePosition({
        x: e.clientX / window.innerWidth,
        y: 1.0 - (e.clientY / window.innerHeight) // Inverser Y pour correspondre aux coordonnées shader
      });
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return (
    <HoverContext.Provider value={{ hoveredCard, setHoveredCard, mousePosition }}>
      {children}
    </HoverContext.Provider>
  );
};

// Shader material custom pour l'effet wave
const WaveShaderMaterial = shaderMaterial(
  {
    time: 0,
    hoveredColor: new THREE.Color('#ffffff'),
    hoveredBounds: new THREE.Vector4(0, 0, 0, 0), // x, y, width, height en coordonnées NDC
    mousePosition: new THREE.Vector2(0, 0),
    isHovered: false,
    waveIntensity: 0.0,
    resolution: new THREE.Vector2(typeof window !== 'undefined' ? window.innerWidth : 1920, typeof window !== 'undefined' ? window.innerHeight : 1080),
    // Propriétés du matériau de base
    color: new THREE.Color('#ffffff'),
    metalness: 0.1,
    roughness: 0.05,
    transmission: 0.8,
    opacity: 0.7,
    thickness: 0.5,
    emissive: new THREE.Color('#ffffff'),
    emissiveIntensity: 0.3,
    clearcoat: 1.0,
    clearcoatRoughness: 0.1,
    ior: 1.5,
  },
  // Vertex shader
  `
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    
    void main() {
      vPosition = position;
      vNormal = normal;
      vUv = uv;
      
      vec4 worldPosition = modelMatrix * vec4(position, 1.0);
      vec4 screenPosition = projectionMatrix * viewMatrix * worldPosition;
      vScreenPosition = screenPosition;
      
      gl_Position = screenPosition;
    }
  `,
  // Fragment shader
  `
    uniform float time;
    uniform vec3 hoveredColor;
    uniform vec4 hoveredBounds;
    uniform vec2 mousePosition;
    uniform bool isHovered;
    uniform float waveIntensity;
    uniform vec2 resolution;
    
    uniform vec3 color;
    uniform float metalness;
    uniform float roughness;
    uniform float transmission;
    uniform float opacity;
    uniform float thickness;
    uniform vec3 emissive;
    uniform float emissiveIntensity;
    uniform float clearcoat;
    uniform float clearcoatRoughness;
    uniform float ior;
    
    varying vec3 vPosition;
    varying vec3 vNormal;
    varying vec2 vUv;
    varying vec4 vScreenPosition;
    
    void main() {
      // Calcul des coordonnées écran normalisées
      vec2 screenUV = (vScreenPosition.xy / vScreenPosition.w) * 0.5 + 0.5;
      screenUV.y = 1.0 - screenUV.y; // Inverser Y pour correspondre aux coordonnées DOM
      
      vec3 finalColor = color;
      vec3 finalEmissive = emissive;
      float finalEmissiveIntensity = emissiveIntensity;
      
      if (isHovered) {
        // Vérifier si le fragment est dans les bounds de la case survolée
        bool inBounds = screenUV.x >= hoveredBounds.x && 
                       screenUV.x <= hoveredBounds.x + hoveredBounds.z &&
                       screenUV.y >= hoveredBounds.y && 
                       screenUV.y <= hoveredBounds.y + hoveredBounds.w;
        
        if (inBounds) {
          // Calculer la distance de la position de la souris (au lieu du centre)
          float distFromMouse = length(screenUV - mousePosition);
          
          // Créer une wave qui se propage de la position de la souris
          float wave = sin(distFromMouse * 30.0 - time * 12.0) * 0.5 + 0.5;
          wave *= waveIntensity;
          
          // Atténuer l'effet selon la distance de la souris
          float distanceAttenuation = 1.0 - smoothstep(0.0, 0.3, distFromMouse);
          wave *= distanceAttenuation;
          
          // Appliquer la couleur complémentaire avec l'effet wave
          finalColor = mix(color, hoveredColor, wave * 0.9);
          finalEmissive = mix(emissive, hoveredColor, wave * 1.2);
          finalEmissiveIntensity = mix(emissiveIntensity, 1.5, wave * 0.7);
        }
      }
      
      // Simuler un matériau physique simple
      vec3 normal = normalize(vNormal);
      float fresnel = pow(1.0 - dot(normal, vec3(0.0, 0.0, 1.0)), 2.0);
      
      vec3 result = finalColor + finalEmissive * finalEmissiveIntensity;
      result = mix(result, finalColor * 1.5, fresnel * 0.3);
      
      gl_FragColor = vec4(result, opacity + transmission * 0.1);
    }
  `
);

extend({ WaveShaderMaterial });

interface ModelProps {
  position?: [number, number, number];
  [key: string]: unknown;
}

interface GLTFResult {
  nodes: { [key: string]: THREE.Mesh };
  materials: { [key: string]: THREE.Material };
}

export function BmsModel(props: ModelProps) {
  const { nodes } = useGLTF('/bms.glb') as unknown as GLTFResult
  const meshRef = useRef<THREE.Mesh>(null!)
  const materialRef = useRef<THREE.ShaderMaterial>(null!)
  const { hoveredCard, mousePosition } = useHover();
  
  useFrame((state) => {
    const time = state.clock.getElapsedTime()
    if (meshRef.current) {        
      // Mouvement de flottement léger
      meshRef.current.position.y = Math.sin(time * 0.6) * 0.3
      meshRef.current.position.x = Math.cos(time * 0.3) * 0.2
    }
    
    if (materialRef.current && materialRef.current.uniforms) {
      materialRef.current.uniforms.time.value = time;
      materialRef.current.uniforms.mousePosition.value = new THREE.Vector2(mousePosition.x, mousePosition.y);
      
      if (hoveredCard && hoveredCard.bounds) {
        materialRef.current.uniforms.isHovered.value = true;
        
        // Utiliser la couleur complémentaire
        const complementaryColor = getComplementaryColor(hoveredCard.color);
        materialRef.current.uniforms.hoveredColor.value = new THREE.Color(complementaryColor);
        
        // Convertir les bounds DOM en coordonnées NDC
        const bounds = hoveredCard.bounds;
        const x = bounds.left / window.innerWidth;
        const y = bounds.top / window.innerHeight;
        const width = bounds.width / window.innerWidth;
        const height = bounds.height / window.innerHeight;
        
        materialRef.current.uniforms.hoveredBounds.value = new THREE.Vector4(x, y, width, height);
        materialRef.current.uniforms.waveIntensity.value = Math.min(time * 2.0, 1.0); // Animation d'entrée
      } else {
        materialRef.current.uniforms.isHovered.value = false;
        if (materialRef.current.uniforms.waveIntensity.value > 0) {
          materialRef.current.uniforms.waveIntensity.value = Math.max(materialRef.current.uniforms.waveIntensity.value - 0.05, 0.0); // Animation de sortie
        }
      }
    }
  })

  return (
    <group {...props} dispose={null}>
      <mesh
        ref={meshRef}
        castShadow
        receiveShadow
        geometry={nodes.Fichier_2?.geometry}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.203}
      >
        <waveShaderMaterial
          ref={materialRef}
          transparent={true}
          side={THREE.DoubleSide}
        />
      </mesh>
    </group>
  )
}

useGLTF.preload('/bms.glb')




